---
# Deploy Kubernetes Applications
# Manages application deployment to K3s cluster using Helm and raw manifests

- name: Deploy Kubernetes Applications
  hosts: localhost
  gather_facts: false

  vars:
    kubeconfig_path: "~/.kube/config"
    manifests_path: "{{ playbook_dir }}/../manifests"

  pre_tasks:
    - name: Check if kubectl is installed
      ansible.builtin.command: kubectl version --client --output=yaml
      register: kubectl_check
      failed_when: false
      changed_when: false
      tags:
        - always

    - name: Fail if kubectl not installed
      ansible.builtin.fail:
        msg: |
          kubectl is not installed or not in PATH.
          Please install kubectl to manage Kubernetes resources.
          See: https://kubernetes.io/docs/tasks/tools/
      when: kubectl_check.rc != 0
      tags:
        - always

    - name: Check Kubernetes cluster connectivity
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Node
        kubeconfig: "{{ kubeconfig_path }}"
      register: cluster_check
      failed_when: false
      tags:
        - always

    - name: Fail if cluster not accessible
      ansible.builtin.fail:
        msg: |
          Cannot connect to Kubernetes cluster.
          Please check:
          - K3s cluster is running
          - ~/.kube/config exists and is valid
          - Network connectivity to cluster
      when: cluster_check.failed | default(false)
      tags:
        - always

  tasks:
    - name: Install required Python packages for Kubernetes
      ansible.builtin.pip:
        name:
          - kubernetes
          - pyyaml
        state: present
      delegate_to: localhost
      tags:
        - dependencies

    # Helm Repository Management
    - name: Add Helm repositories
      kubernetes.core.helm_repository:
        name: "{{ item.name }}"
        repo_url: "{{ item.url }}"
        force_update: true
        kubeconfig: "{{ kubeconfig_path }}"
      loop: "{{ k8s_helm_repositories }}"
      tags:
        - helm
        - repositories

    # Deploy cert-manager via Helm
    - name: Deploy cert-manager via Helm
      kubernetes.core.helm:
        name: cert-manager
        chart_ref: jetstack/cert-manager
        release_namespace: cert-manager
        create_namespace: true
        kubeconfig: "{{ kubeconfig_path }}"
        values_files:
          - "{{ manifests_path }}/helm-values/cert-manager.yml"
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300
      tags:
        - helm
        - cert-manager

    # Wait for cert-manager to be ready
    - name: Wait for cert-manager webhook to be ready
      kubernetes.core.k8s_info:
        api_version: apps/v1
        kind: Deployment
        name: cert-manager-webhook
        namespace: cert-manager
        kubeconfig: "{{ kubeconfig_path }}"
        wait: true
        wait_condition:
          type: Available
          status: "True"
        wait_timeout: 300
      tags:
        - cert-manager
        - wait

    # Apply raw Kubernetes manifests
    - name: Create cert-manager ClusterIssuer from template
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition: "{{ lookup('template', manifests_path + '/raw-manifests/cert-manager-issuer.yml') | from_yaml_all | list }}"
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 120
      tags:
        - cert-manager
        - issuer

    # Create MinIO certificate from template
    - name: Create MinIO certificate from template
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition: "{{ lookup('template', manifests_path + '/templates/minio-certificate.yml.j2') | from_yaml }}"
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300
      tags:
        - certificates
        - minio

    # Verify certificate was issued
    - name: Check MinIO certificate status
      kubernetes.core.k8s_info:
        api_version: cert-manager.io/v1
        kind: Certificate
        name: "{{ minio_certificate_name }}"
        namespace: cert-manager
        kubeconfig: "{{ kubeconfig_path }}"
      register: minio_cert_status
      tags:
        - certificates
        - verify

    - name: Display certificate status
      ansible.builtin.debug:
        msg: |
          MinIO Certificate Status:
          Name: {{ minio_cert_status.resources[0].metadata.name }}
          Ready: {{ minio_cert_status.resources[0].status.conditions |
            selectattr('type', 'equalto', 'Ready') |
            map(attribute='status') | first | default('Unknown') }}
          Secret: {{ minio_cert_status.resources[0].spec.secretName }}
      when: minio_cert_status.resources | length > 0
      tags:
        - certificates
        - verify

  post_tasks:
    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          Kubernetes Applications Deployment Complete!
          ==========================================

          ✓ cert-manager deployed via Helm
          ✓ ClusterIssuer configured for Let's Encrypt + Cloudflare
          ✓ MinIO certificate requested and issued

          Next Steps:
          1. Copy certificate to MinIO server (pi-cm5-4)
          2. Configure MinIO for HTTPS
          3. Test internal HTTPS access to MinIO

          Useful Commands:
          - Check certificates: kubectl get certificates -A
          - Check cert-manager logs: kubectl logs -n cert-manager -l app=cert-manager
          - View certificate details: kubectl describe certificate {{ minio_certificate_name }} -n cert-manager
      tags:
        - summary
