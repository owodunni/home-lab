# SnapRAID configuration file for Beelink media storage
# Generated by Ansible - do not edit manually
# Architecture: {{ snapraid_data_drives | length }} data drives + {{ snapraid_parity_drives | length }} parity drive(s)

# Parity file location(s)
{% for parity_file in snapraid_parity_drives %}
parity {{ parity_file }}
{% endfor %}

# Content file locations (metadata about file checksums and parity)
# Multiple content files for redundancy - if one disk fails, metadata survives
{% for content_file in snapraid_content_files %}
content {{ content_file }}
{% endfor %}

# Data drives configuration
{% for drive in snapraid_data_drives %}
data {{ drive.name }} {{ drive.path }}/
{% endfor %}

# Exclusions - files/directories to ignore
# Temporary files and incomplete downloads don't need parity protection
exclude *.unrecoverable
exclude /tmp/
exclude /lost+found/
exclude downloads/
exclude appdata/
exclude *.!sync
exclude .AppleDouble
exclude ._AppleDouble
exclude .DS_Store
exclude ._.DS_Store
exclude .Thumbs.db
exclude .fseventsd
exclude .Spotlight-V100
exclude .TemporaryItems
exclude .Trashes
exclude .nfo

# Exclude incomplete downloads from parity calculation
exclude incomplete/
exclude */incomplete/

# Autosave: Save parity state every N blocks (500 blocks ~ every 2-3 minutes)
# Allows resuming interrupted sync operations
autosave 500

# Block size: 256 KiB (default, good balance for large media files)
# block_size 256

# Hash algorithm: Use blake2 for data integrity verification (faster than sha256)
# hash blake2

# Pool configuration (optional - not used with MergerFS)
# MergerFS handles file placement, SnapRAID only provides parity

# Smart self-test monitoring
# smartctl /dev/disk/by-id/nvme-CT2000P310SSD8_24454C177944
# smartctl /dev/disk/by-id/nvme-CT2000P310SSD8_24454C37CB1B
# smartctl /dev/disk/by-id/nvme-CT2000P310SSD8_24454C40D38E
